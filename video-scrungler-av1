#!/usr/bin/env sh

set -o errexit
set -o nounset

# video-scrungler-av1: transcode videos to 10-bit AV1 at a file size target

# SPDX-License-Identifier: MIT

# Copyright (c) 2025 multiplealiases
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# “Software”), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
# NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
# THE USE OR OTHER DEALINGS IN THE SOFTWARE.

banner() {
    echo transcode videos to 10-bit AV1 at a file size target
}

usage() {
    echo Usage: video-scrungler-av1 [video size in MiB] [video file]
}

die() {
        # shellcheck disable=SC2059
        printf "$@"
        exit 1
}

if [ "$1" = '-h' ] || [ "$1" = '--help' ]
then
    cat << EOF
$(banner)
$(usage)
EOF
    exit
fi

if [ $# -ne 2 ]
then
    die 'error: got %s arguments, expected 2\ntry -h for help\n' "$#"
fi

size="$1"
filepath="$(realpath "$2")"
audio_bitrate=128

filename="$(basename "${filepath}")"
base_filename="${filename%.*}"
output_filename="${base_filename}"-"${size}"MiB-av1.mp4

# ripped straight from https://superuser.com/a/945604
float_length="$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${filepath}")"
length="${float_length%.*}"
# overestimate the length by 5 seconds
# to undershoot rather than overshoot the limit
length="$(( length + 5 ))"

# we need to check if a 'j' (JPEG/full levels, 0-255) pixel format is in use
# and expand its range by a studio (16-235) -> full (0-255) conversion.
# this is a hack, I don't like doing this, but for some reason it works.
pix_fmt="$(ffprobe -v error -of default=noprint_wrappers=1:nokey=1 -show_entries 'stream=pix_fmt' -select_streams V:0 "${filepath}")"
case "$pix_fmt" in
*j*)
    # to convert [16, 235] to [0, 255]:
    # subtract by 16 to get [0, 219]
    # multiply by 255/219 to get [0, 255]
    # clip values between [0, 255] for good measure.
    convert_levels="geq=lum='clip((p(X, Y) - 16) * 1.164383562, 0, 255)':cb='clip((p(X, Y) - 16) * 1.164383562, 0, 255)':cr='clip((p(X, Y) - 16) * 1.164383562, 0, 255)', "
    ;;
*)
    convert_levels=''
    ;;
esac

# underestimate the target bitrate by 2%
# so that the output file is more likely to be below the file size limit.
# size is given in bytes, but we need bits.
target_bitrate="$(( ((8 * 1000 * size) / length) - audio_bitrate ))"

# The video filter is adapted from https://stackoverflow.com/a/54064036
1>&2 printf '>>> encoding to %s\n' "${output_filename}"
ffmpeg -i "$filepath" -hide_banner -loglevel error \
    -threads 16 -c:v libsvtav1 -b:v "${target_bitrate}"k -preset 8 -pix_fmt yuv420p10le \
    -vf "${convert_levels}scale='if(gte(ih, iw), min(720, iw), -4)':'if(lt(ih, iw), min(720, ih), -4)';" \
    -c:a libopus -b:a "${audio_bitrate}"k \
    -movflags +faststart -y "${output_filename}"
